<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Matrix Transform Visualizer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    display: flex;
    height: 100vh;
    overflow: hidden;
}

/* Sidebar */
.sidebar {
    width: 300px;
    min-width: 300px;
    background: #16213e;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 18px;
    border-right: 1px solid #0f3460;
}
.sidebar h1 {
    font-size: 18px;
    color: #e94560;
    border-bottom: 1px solid #0f3460;
    padding-bottom: 10px;
}
.sidebar h2 {
    font-size: 13px;
    text-transform: uppercase;
    color: #888;
    letter-spacing: 1px;
    margin-bottom: 6px;
}
.section {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

/* Matrix sliders */
.matrix-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}
.slider-group {
    display: flex;
    flex-direction: column;
    gap: 2px;
}
.slider-group label {
    font-size: 12px;
    color: #aaa;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.slider-group input[type="range"] {
    width: 100%;
    accent-color: #e94560;
    cursor: pointer;
}
.slider-group input[type="number"] {
    width: 60px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    color: #e0e0e0;
    padding: 2px 4px;
    font-size: 12px;
    border-radius: 3px;
    text-align: right;
}

/* Eigen display */
.eigen-box {
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 6px;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    color: #ff6b6b;
    white-space: pre-wrap;
    min-height: 40px;
}

/* Controls */
.controls {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}
.controls button {
    flex: 1;
    min-width: 50px;
    padding: 8px 4px;
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #1a4080;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    transition: background 0.15s;
}
.controls button:hover { background: #1a4080; }
.controls button.active { background: #e94560; border-color: #e94560; }

/* Vertices list */
.vertex-list {
    font-family: 'Courier New', monospace;
    font-size: 12px;
    color: #aaa;
    max-height: 120px;
    overflow-y: auto;
}
.vertex-list div { padding: 2px 0; }

.step-info {
    font-size: 13px;
    color: #ccc;
    text-align: center;
    padding: 4px;
    background: #1a1a2e;
    border-radius: 4px;
}

/* Canvas area */
.canvas-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    position: relative;
}
canvas {
    background: #16213e;
    border-radius: 8px;
    cursor: crosshair;
}
.hint {
    position: absolute;
    bottom: 30px;
    color: #555;
    font-size: 12px;
    pointer-events: none;
}
</style>
</head>
<body>

<div class="sidebar">
    <h1>Matrix Transform</h1>

    <div class="section">
        <h2>Matrix A</h2>
        <div class="matrix-grid">
            <div class="slider-group">
                <label>a <input type="number" id="num-a" value="1" step="0.01" min="-3" max="3"></label>
                <input type="range" id="slider-a" min="-3" max="3" step="0.01" value="1">
            </div>
            <div class="slider-group">
                <label>b <input type="number" id="num-b" value="0" step="0.01" min="-3" max="3"></label>
                <input type="range" id="slider-b" min="-3" max="3" step="0.01" value="0">
            </div>
            <div class="slider-group">
                <label>c <input type="number" id="num-c" value="0" step="0.01" min="-3" max="3"></label>
                <input type="range" id="slider-c" min="-3" max="3" step="0.01" value="0">
            </div>
            <div class="slider-group">
                <label>d <input type="number" id="num-d" value="1" step="0.01" min="-3" max="3"></label>
                <input type="range" id="slider-d" min="-3" max="3" step="0.01" value="1">
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Eigenvalues / Eigenvectors</h2>
        <div class="eigen-box" id="eigen-display">No matrix set</div>
    </div>

    <div class="section">
        <h2>Animation</h2>
        <div class="step-info" id="step-info">Step 0</div>
        <div class="controls">
            <button id="btn-reset" title="Reset">Reset</button>
            <button id="btn-step-back" title="Step back">&lt;</button>
            <button id="btn-play" title="Play/Pause">Play</button>
            <button id="btn-step-fwd" title="Step forward">&gt;</button>
        </div>
    </div>

    <div class="section">
        <h2>Vertices</h2>
        <div class="vertex-list" id="vertex-list">Click on canvas to add vertices</div>
        <div class="controls">
            <button id="btn-clear">Clear</button>
        </div>
    </div>
</div>

<div class="canvas-area">
    <canvas id="canvas"></canvas>
    <div class="hint">Click to add vertices. Adjust matrix sliders. Press Play.</div>
</div>

<script>
(function() {
    'use strict';

    // ── State ──
    const state = {
        vertices: [],
        matrix: { a: 1, b: 0, c: 0, d: 1 },
        history: [],
        currentStep: 0,
        isPlaying: false,
        eigenvalues: [],
        eigenvectors: [],
        isComplex: false,
        scale: 40,
        maxSteps: 50,
        timer: null,
    };

    // ── DOM refs ──
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const eigenDisplay = document.getElementById('eigen-display');
    const stepInfo = document.getElementById('step-info');
    const vertexList = document.getElementById('vertex-list');
    const btnPlay = document.getElementById('btn-play');
    const btnReset = document.getElementById('btn-reset');
    const btnStepFwd = document.getElementById('btn-step-fwd');
    const btnStepBack = document.getElementById('btn-step-back');
    const btnClear = document.getElementById('btn-clear');

    // ── Canvas sizing ──
    function resizeCanvas() {
        const area = canvas.parentElement;
        const size = Math.min(area.clientWidth - 40, area.clientHeight - 40);
        canvas.width = size;
        canvas.height = size;
        draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // ── Coordinate transforms ──
    function mathToCanvas(x, y) {
        return [
            canvas.width / 2 + x * state.scale,
            canvas.height / 2 - y * state.scale
        ];
    }
    function canvasToMath(px, py) {
        return [
            (px - canvas.width / 2) / state.scale,
            -(py - canvas.height / 2) / state.scale
        ];
    }

    // ── Matrix math (ported from quad.py) ──
    function applyMatrix(mat, vertices) {
        return vertices.map(([x, y]) => [
            mat.a * x + mat.b * y,
            mat.c * x + mat.d * y
        ]);
    }

    function computeEigen(mat) {
        const { a, b, c, d } = mat;
        const trace = a + d;
        const det = a * d - b * c;
        const disc = trace * trace - 4 * det;

        const eigenvalues = [];
        const eigenvectors = [];

        if (disc >= 0) {
            const sq = Math.sqrt(disc);
            for (const l of [(trace + sq) / 2, (trace - sq) / 2]) {
                eigenvalues.push(l);
                if (Math.abs(b) > 1e-12) {
                    eigenvectors.push([b, l - a]);
                } else if (Math.abs(c) > 1e-12) {
                    eigenvectors.push([l - d, c]);
                } else {
                    if (Math.abs(a - l) < 1e-12) {
                        eigenvectors.push([1, 0]);
                    } else {
                        eigenvectors.push([0, 1]);
                    }
                }
            }
            state.isComplex = false;
        } else {
            const re = trace / 2;
            const im = Math.sqrt(-disc) / 2;
            eigenvalues.push({ re, im });
            eigenvalues.push({ re, im: -im });
            state.isComplex = true;
        }

        state.eigenvalues = eigenvalues;
        state.eigenvectors = eigenvectors;
    }

    // ── Build animation history ──
    function buildHistory() {
        if (state.vertices.length === 0) {
            state.history = [];
            return;
        }
        state.history = [state.vertices.slice()];
        let cur = state.vertices.slice();
        for (let i = 0; i < state.maxSteps; i++) {
            cur = applyMatrix(state.matrix, cur);
            state.history.push(cur);
        }
    }

    // ── Auto-zoom: compute scale from bounding box ──
    function computeScale() {
        if (state.history.length === 0) {
            state.scale = 40;
            return;
        }
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const frame of state.history) {
            for (const [x, y] of frame) {
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
            }
        }
        const rangeX = maxX - minX || 1;
        const rangeY = maxY - minY || 1;
        const margin = 1.3;
        const sX = canvas.width / (rangeX * margin);
        const sY = canvas.height / (rangeY * margin);
        state.scale = Math.min(sX, sY, 200);
        if (state.scale < 1) state.scale = 1;
    }

    // ── Drawing ──
    function draw() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#16213e';
        ctx.fillRect(0, 0, w, h);

        drawGrid();
        drawAxes();
        drawEigenvectors();
        drawPolygon();
    }

    function drawGrid() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;

        const step = state.scale;
        if (step < 5) return;

        const cx = w / 2;
        const cy = h / 2;

        // vertical lines
        for (let x = cx % step; x < w; x += step) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
        }
        // horizontal lines
        for (let y = cy % step; y < h; y += step) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
        }
    }

    function drawAxes() {
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;

        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1;

        // X axis
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
        // Y axis
        ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();

        // Tick labels
        ctx.fillStyle = '#666';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        const step = state.scale;
        if (step >= 10) {
            for (let i = 1; i * step + cx < w; i++) {
                ctx.fillText(i, cx + i * step, cy + 14);
                ctx.fillText(-i, cx - i * step, cy + 14);
            }
            ctx.textAlign = 'right';
            for (let i = 1; i * step + cy < h; i++) {
                ctx.fillText(-i, cx - 5, cy + i * step + 4);
                ctx.fillText(i, cx - 5, cy - i * step + 4);
            }
        }
    }

    function drawEigenvectors() {
        if (state.isComplex || state.eigenvectors.length === 0) return;

        const diag = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
        const tMax = diag / state.scale;

        for (let i = 0; i < state.eigenvectors.length; i++) {
            let [vx, vy] = state.eigenvectors[i];
            const norm = Math.sqrt(vx * vx + vy * vy);
            if (norm < 1e-12) continue;
            vx /= norm;
            vy /= norm;

            const [x1, y1] = mathToCanvas(-vx * tMax, -vy * tMax);
            const [x2, y2] = mathToCanvas(vx * tMax, vy * tMax);

            ctx.strokeStyle = 'rgba(255, 80, 80, 0.5)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([8, 6]);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label
            const lx = vx * tMax * 0.35;
            const ly = vy * tMax * 0.35;
            const [labelX, labelY] = mathToCanvas(lx, ly);
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            const ev = state.eigenvalues[i];
            ctx.fillText(`v${i + 1} (λ=${ev.toFixed(3)})`, labelX + 5, labelY - 5);
        }
    }

    function drawPolygon() {
        if (state.history.length === 0 || state.vertices.length === 0) return;

        const step = Math.min(state.currentStep, state.history.length - 1);
        const pts = state.history[step];

        if (pts.length === 0) return;

        // Draw filled polygon
        if (pts.length >= 3) {
            ctx.fillStyle = 'rgba(233, 69, 96, 0.15)';
            ctx.beginPath();
            const [sx, sy] = mathToCanvas(pts[0][0], pts[0][1]);
            ctx.moveTo(sx, sy);
            for (let i = 1; i < pts.length; i++) {
                const [px, py] = mathToCanvas(pts[i][0], pts[i][1]);
                ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }

        // Draw edges
        ctx.strokeStyle = '#e94560';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const [sx, sy] = mathToCanvas(pts[0][0], pts[0][1]);
        ctx.moveTo(sx, sy);
        for (let i = 1; i < pts.length; i++) {
            const [px, py] = mathToCanvas(pts[i][0], pts[i][1]);
            ctx.lineTo(px, py);
        }
        if (pts.length >= 3) ctx.closePath();
        ctx.stroke();

        // Draw vertices and labels
        for (let i = 0; i < pts.length; i++) {
            const [px, py] = mathToCanvas(pts[i][0], pts[i][1]);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(px, py, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(String.fromCharCode(65 + i), px, py - 10);
        }
    }

    // ── Eigen display ──
    function updateEigenDisplay() {
        computeEigen(state.matrix);
        const step = state.currentStep;
        let text = '';

        const { a, b, c, d } = state.matrix;
        text += `A = [[${a.toFixed(2)}, ${b.toFixed(2)}],\n     [${c.toFixed(2)}, ${d.toFixed(2)}]]\n\n`;

        if (state.isComplex) {
            const ev = state.eigenvalues[0];
            const mod = Math.sqrt(ev.re * ev.re + ev.im * ev.im);
            const modN = step > 0 ? Math.pow(mod, step) : 1;
            text += `λ = ${ev.re.toFixed(3)} ± ${Math.abs(ev.im).toFixed(3)}i\n`;
            text += `|λ| = ${mod.toFixed(4)}\n`;
            text += `|λ|^${step} = ${modN.toFixed(4)}`;
        } else {
            for (let i = 0; i < state.eigenvalues.length; i++) {
                const ev = state.eigenvalues[i];
                const evN = step > 0 ? Math.pow(ev, step) : 1;
                const sign = isNaN(evN) ? 'undef' : evN.toFixed(4);
                text += `λ${i + 1} = ${ev.toFixed(3)}`;
                if (state.eigenvectors[i]) {
                    const [vx, vy] = state.eigenvectors[i];
                    const norm = Math.sqrt(vx * vx + vy * vy);
                    if (norm > 1e-12) {
                        text += `  v=(${(vx/norm).toFixed(2)}, ${(vy/norm).toFixed(2)})`;
                    }
                }
                text += `\nλ${i + 1}^${step} = ${sign}\n`;
            }
        }

        eigenDisplay.textContent = text;
        stepInfo.textContent = `Step ${step}`;
    }

    // ── Vertex list ──
    function updateVertexList() {
        if (state.vertices.length === 0) {
            vertexList.textContent = 'Click on canvas to add vertices';
            return;
        }
        vertexList.innerHTML = state.vertices.map((v, i) =>
            `<div>${String.fromCharCode(65 + i)}: (${v[0].toFixed(2)}, ${v[1].toFixed(2)})</div>`
        ).join('');
    }

    // ── Recalculate everything ──
    function recalculate() {
        computeEigen(state.matrix);
        buildHistory();
        computeScale();
        updateEigenDisplay();
        draw();
    }

    // ── Slider / number sync ──
    ['a', 'b', 'c', 'd'].forEach(key => {
        const slider = document.getElementById('slider-' + key);
        const num = document.getElementById('num-' + key);

        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            num.value = val;
            state.matrix[key] = val;
            state.currentStep = 0;
            stopAnimation();
            recalculate();
        });

        num.addEventListener('input', () => {
            let val = parseFloat(num.value);
            if (isNaN(val)) return;
            val = Math.max(-3, Math.min(3, val));
            slider.value = val;
            state.matrix[key] = val;
            state.currentStep = 0;
            stopAnimation();
            recalculate();
        });
    });

    // ── Canvas click → add vertex ──
    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const [mx, my] = canvasToMath(px, py);

        state.vertices.push([mx, my]);
        state.currentStep = 0;
        stopAnimation();
        recalculate();
        updateVertexList();
    });

    // ── Animation controls ──
    function stopAnimation() {
        state.isPlaying = false;
        btnPlay.classList.remove('active');
        btnPlay.textContent = 'Play';
        if (state.timer) {
            clearTimeout(state.timer);
            state.timer = null;
        }
    }

    function tick() {
        if (!state.isPlaying) return;
        if (state.vertices.length === 0) { stopAnimation(); return; }

        state.currentStep++;
        if (state.currentStep >= state.history.length) {
            state.currentStep = 0;
        }
        updateEigenDisplay();
        draw();
        state.timer = setTimeout(tick, 300);
    }

    btnPlay.addEventListener('click', () => {
        if (state.vertices.length === 0) return;
        if (state.isPlaying) {
            stopAnimation();
        } else {
            state.isPlaying = true;
            btnPlay.classList.add('active');
            btnPlay.textContent = 'Pause';
            tick();
        }
    });

    btnReset.addEventListener('click', () => {
        stopAnimation();
        state.currentStep = 0;
        updateEigenDisplay();
        draw();
    });

    btnStepFwd.addEventListener('click', () => {
        if (state.history.length === 0) return;
        stopAnimation();
        state.currentStep = (state.currentStep + 1) % state.history.length;
        updateEigenDisplay();
        draw();
    });

    btnStepBack.addEventListener('click', () => {
        if (state.history.length === 0) return;
        stopAnimation();
        state.currentStep = (state.currentStep - 1 + state.history.length) % state.history.length;
        updateEigenDisplay();
        draw();
    });

    btnClear.addEventListener('click', () => {
        stopAnimation();
        state.vertices = [];
        state.history = [];
        state.currentStep = 0;
        state.scale = 40;
        updateVertexList();
        updateEigenDisplay();
        draw();
    });

    // ── Init ──
    resizeCanvas();
    recalculate();
    updateVertexList();
})();
</script>
</body>
</html>
